"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[442],{57292:function(e,n,t){t.d(n,{f:function(){return a}});var r=t(95256),i=t(27378);function a(e){let{language:n,replace:t,section:a,source:o}=e;if("object"==typeof o&&"default"in o&&(o=o.default),a){const e=new RegExp(`// <${a}>\\s([\\s\\S]*?)\\s// </${a}>\\s`,"g");o=o.split(e).reduce(((e,n,t)=>t%2==0?e:`${e}\n\n${n}`),"")}if(o=o.replace(/\/\/ <.*?\n/g,""),t)for(const[r,i]of Object.entries(t))o=o.replace(new RegExp(r,"gs"),i);return o=o.trim(),o.includes("\n")||(o+="\n"),i.createElement(r.Z.pre,null,i.createElement(r.Z.code,{children:o,className:`language-${n}`,mdxType:"code",originalType:"code",parentName:"pre"}))}},10177:function(e,n,t){t.r(n),t.d(n,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c}});var r=t(25773),i=(t(27378),t(35318)),a=t(57292);const o={id:"uth-bridge-concept",title:"Bridge concept"},s=void 0,l={unversionedId:"uth-bridge-concept",id:"uth-bridge-concept",title:"Bridge concept",description:'To make use of any schema, uniforms have to create a bridge of it - a unified schema mapper. The Bridge class is an abstract class, which should be extended to create custom bridges. It implements all of the required methods and throws an error with meaningful "method not implemented" error.',source:"@site/../docs/uth-bridge-concept.mdx",sourceDirName:".",slug:"/uth-bridge-concept",permalink:"/docs/uth-bridge-concept",draft:!1,tags:[],version:"current",frontMatter:{id:"uth-bridge-concept",title:"Bridge concept"},sidebar:"docs",previous:{title:"AutoField algorithm",permalink:"/docs/uth-autofield-algorithm"}},d={},c=[],u={toc:c};function m(e){let{components:n,...o}=e;return(0,i.kt)("wrapper",(0,r.Z)({},u,o,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"To make use of any schema, uniforms have to create a ",(0,i.kt)("em",{parentName:"p"},"bridge")," of it - a unified schema mapper. The ",(0,i.kt)("inlineCode",{parentName:"p"},"Bridge"),' class is an abstract class, which should be extended to create custom bridges. It implements all of the required methods and throws an error with meaningful "method not implemented" error.'),(0,i.kt)(a.f,{language:"tsx",replace:{"(  .*?) {\n.*?  }":"$1;","(import |  // eslint).*?\n":""},source:t(75079),mdxType:"CodeSection"}))}m.isMDXComponent=!0},75079:function(e,n,t){t.r(n),n.default="import invariant from 'invariant';\nimport set from 'lodash/set';\n\nimport { UnknownObject } from './types';\n\nexport abstract class Bridge {\n  // Each bridge can have a different set of parameters.\n  constructor(...args: any[]) {\n    invariant(\n      this.constructor !== Bridge,\n      'Bridge cannot be instantiated (args=%o).',\n      { args },\n    );\n  }\n\n  /**\n   * Get an error for field `name` out of `error`. There is no standarized\n   * format, but fields treat truthy values as a sign of being invalid. Fields\n   * receive this as a `error` guaranteed prop.\n   */\n  getError(name: string, error: unknown): unknown {\n    return invariant(\n      false,\n      '%s have not implemented `getError` method (args=%o).',\n      this.constructor.name,\n      { name, error },\n    );\n  }\n\n  /**\n   * Get an error message for field `name` out of `error`. If there is no error,\n   * return an empty string. Fields receive this as a `errorMessage` guaranteed\n   * prop.\n   */\n  getErrorMessage(name: string, error: unknown): string {\n    return invariant(\n      false,\n      '%s have not implemented `getErrorMessage` method (args=%o).',\n      this.constructor.name,\n      { name, error },\n    );\n  }\n\n  /**\n   * Get all error messages from `error`. Only `ErrorsField` make use of that\n   * (in builtin themes).\n   */\n  getErrorMessages(error: unknown): string[] {\n    return invariant(\n      false,\n      '%s have not implemented `getErrorMessages` method (args=%o).',\n      this.constructor.name,\n      { error },\n    );\n  }\n\n  /**\n   * Get internal field definition for field `name`. Fields receive this as a\n   * `field` guaranteed prop. There is no standarized field format. Most bridges\n   * use it as a common object, used in calculation of initial values, props,\n   * and types.\n   */\n  getField(name: string): unknown {\n    return invariant(\n      false,\n      '%s have not implemented `getField` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  /**\n   * Get initial value of field `name`. It is used as a default when no value is\n   * set (e.g. the form is rendered with an empty `model`). Additionally,\n   * `props` are this field instance props. If a field is rendered multiple\n   * times, this function will be called multiple times, possibly with different\n   * `props`.\n   */\n  getInitialValue(name: string): unknown {\n    return invariant(\n      false,\n      '%s have not implemented `getInitialValue` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  /**\n   * Get initial model value recursively.\n   */\n  getInitialModel(): UnknownObject {\n    const initialModel: UnknownObject = {};\n    const subFields = this.getSubfields();\n    for (const fieldName of subFields) {\n      const initialValue = this.getInitialValue(fieldName);\n      set(initialModel, fieldName, initialValue);\n    }\n    return initialModel;\n  }\n\n  /**\n   * Get props defined in schema for a field `name`. There are no required nor\n   * banned fields, however properties like `required` are often available.\n   */\n  getProps(name: string): UnknownObject {\n    return invariant(\n      false,\n      '%s have not implemented `getProps` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  /**\n   * Get a list of subfields of field `name` or top-level fields, if no `name`\n   * is passed.\n   */\n  getSubfields(name?: string): string[] {\n    return invariant(\n      false,\n      '%s have not implemented `getSubfields` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  /**\n   * There is no standarized field type format. However, `AutoField` component\n   * will work correctly only with standard JavaScript constructors, like\n   * `String` or `Number`.\n   */\n  getType(name: string): unknown {\n    return invariant(\n      false,\n      '%s have not implemented `getType` method (args=%o).',\n      this.constructor.name,\n      { name },\n    );\n  }\n\n  /**\n   * Get a validator function. The `options` here are from the `validator` prop\n   * of the form. A validator function receives a model and returns an error or\n   * a promise that will resolve (not reject!) with an error. If there is no\n   * error, return (or resolve with) a `null` value instead.\n   */\n  getValidator(options?: unknown): (model: UnknownObject) => unknown {\n    return invariant(\n      false,\n      '%s have not implemented `getValidator` method (args=%o).',\n      this.constructor.name,\n      { options },\n    );\n  }\n}\n"}}]);